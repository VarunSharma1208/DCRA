{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/DataTile\n */\n\n\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { assign } from '../obj.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\nimport { toPromise } from '../functions.js';\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the tiles.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./State.js\").default} [state] The source state.\n * @property {number} [tilePixelRatio] Tile pixel ratio.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nvar DataTileSource =\n/** @class */\nfunction (_super) {\n  __extends(DataTileSource, _super);\n  /**\n   * @param {Options} options Image tile options.\n   */\n\n\n  function DataTileSource(options) {\n    var _this = this;\n\n    var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;\n    var tileGrid = options.tileGrid;\n\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize\n      });\n    }\n\n    _this = _super.call(this, {\n      cacheSize: 0.1,\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      opaque: options.opaque,\n      state: options.state,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate\n    }) || this;\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n\n    _this.tileLoadingKeys_ = {};\n    /**\n     * @private\n     */\n\n    _this.loader_ = options.loader;\n    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);\n    /**\n     * @type {number}\n     */\n\n    _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    return _this;\n  }\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n\n\n  DataTileSource.prototype.setLoader = function (loader) {\n    this.loader_ = loader;\n  };\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!DataTile} Tile.\n   */\n\n\n  DataTileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var tileCoordKey = getKeyZXY(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    }\n\n    var sourceLoader = this.loader_;\n\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(z, x, y);\n      });\n    }\n\n    var tile = new DataTile(assign({\n      tileCoord: [z, x, y],\n      loader: loader\n    }, this.tileOptions));\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  };\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n\n\n  DataTileSource.prototype.handleTileChange_ = function (event) {\n    var tile =\n    /** @type {import(\"../Tile.js\").default} */\n    event.target;\n    var uid = getUid(tile);\n    var tileState = tile.getState();\n    var type;\n\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;\n    }\n\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  };\n\n  return DataTileSource;\n}(TileSource);\n\nexport default DataTileSource;","map":{"version":3,"sources":["../src/source/DataTile.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { assign } from '../obj.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\nimport { toPromise } from '../functions.js';\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the tiles.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./State.js\").default} [state] The source state.\n * @property {number} [tilePixelRatio] Tile pixel ratio.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar DataTileSource = /** @class */ (function (_super) {\n    __extends(DataTileSource, _super);\n    /**\n     * @param {Options} options Image tile options.\n     */\n    function DataTileSource(options) {\n        var _this = this;\n        var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;\n        var tileGrid = options.tileGrid;\n        if (tileGrid === undefined && projection) {\n            tileGrid = createXYZ({\n                extent: extentFromProjection(projection),\n                maxResolution: options.maxResolution,\n                maxZoom: options.maxZoom,\n                minZoom: options.minZoom,\n                tileSize: options.tileSize,\n            });\n        }\n        _this = _super.call(this, {\n            cacheSize: 0.1,\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            projection: projection,\n            tileGrid: tileGrid,\n            opaque: options.opaque,\n            state: options.state,\n            tilePixelRatio: options.tilePixelRatio,\n            wrapX: options.wrapX,\n            transition: options.transition,\n            interpolate: options.interpolate,\n        }) || this;\n        /**\n         * @private\n         * @type {!Object<string, boolean>}\n         */\n        _this.tileLoadingKeys_ = {};\n        /**\n         * @private\n         */\n        _this.loader_ = options.loader;\n        _this.handleTileChange_ = _this.handleTileChange_.bind(_this);\n        /**\n         * @type {number}\n         */\n        _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n        return _this;\n    }\n    /**\n     * @param {Loader} loader The data loader.\n     * @protected\n     */\n    DataTileSource.prototype.setLoader = function (loader) {\n        this.loader_ = loader;\n    };\n    /**\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!DataTile} Tile.\n     */\n    DataTileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            return this.tileCache.get(tileCoordKey);\n        }\n        var sourceLoader = this.loader_;\n        function loader() {\n            return toPromise(function () {\n                return sourceLoader(z, x, y);\n            });\n        }\n        var tile = new DataTile(assign({ tileCoord: [z, x, y], loader: loader }, this.tileOptions));\n        tile.key = this.getKey();\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n        this.tileCache.set(tileCoordKey, tile);\n        return tile;\n    };\n    /**\n     * Handle tile change events.\n     * @param {import(\"../events/Event.js\").default} event Event.\n     */\n    DataTileSource.prototype.handleTileChange_ = function (event) {\n        var tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n        var uid = getUid(tile);\n        var tileState = tile.getState();\n        var type;\n        if (tileState == TileState.LOADING) {\n            this.tileLoadingKeys_[uid] = true;\n            type = TileEventType.TILELOADSTART;\n        }\n        else if (uid in this.tileLoadingKeys_) {\n            delete this.tileLoadingKeys_[uid];\n            type =\n                tileState == TileState.ERROR\n                    ? TileEventType.TILELOADERROR\n                    : tileState == TileState.LOADED\n                        ? TileEventType.TILELOADEND\n                        : undefined;\n        }\n        if (type) {\n            this.dispatchEvent(new TileSourceEvent(type, tile));\n        }\n    };\n    return DataTileSource;\n}(TileSource));\nexport default DataTileSource;\n//# sourceMappingURL=DataTile.js.map"]},"metadata":{},"sourceType":"module"}