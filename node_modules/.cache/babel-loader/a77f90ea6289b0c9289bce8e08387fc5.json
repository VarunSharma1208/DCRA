{"ast":null,"code":"/**\n * @module ol/source/Cluster\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport { add as addCoordinate, scale as scaleCoordinate } from '../coordinate.js';\nimport { assert } from '../asserts.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate, getCenter } from '../extent.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<Feature>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point} and an array\n * of {@link module:ol/Feature} included in this cluster. Must return a\n * {@link module:ol/Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\n\nvar Cluster =\n/** @class */\nfunction (_super) {\n  __extends(Cluster, _super);\n  /**\n   * @param {Options} options Cluster options.\n   */\n\n\n  function Cluster(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n\n\n    _this.resolution = undefined;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.distance = options.distance !== undefined ? options.distance : 20;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.minDistance = options.minDistance || 0;\n    /**\n     * @type {number}\n     * @protected\n     */\n\n    _this.interpolationRatio = 0;\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n\n    _this.features = [];\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n\n    _this.geometryFunction = options.geometryFunction || function (feature) {\n      var geometry = feature.getGeometry();\n      assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n\n      return geometry;\n    };\n    /**\n     * @type {function(Point, Array<Feature>):Feature}\n     * @private\n     */\n\n\n    _this.createCustomCluster_ = options.createCluster;\n    /**\n     * @type {VectorSource}\n     * @protected\n     */\n\n    _this.source = null;\n    _this.boundRefresh_ = _this.refresh.bind(_this);\n\n    _this.updateDistance(_this.distance, _this.minDistance);\n\n    _this.setSource(options.source || null);\n\n    return _this;\n  }\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n\n\n  Cluster.prototype.clear = function (opt_fast) {\n    this.features.length = 0;\n\n    _super.prototype.clear.call(this, opt_fast);\n  };\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n\n\n  Cluster.prototype.getDistance = function () {\n    return this.distance;\n  };\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n\n\n  Cluster.prototype.getSource = function () {\n    return this.source;\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n\n    if (resolution !== this.resolution) {\n      this.resolution = resolution;\n      this.refresh();\n    }\n  };\n  /**\n   * Set the distance within which features will be clusterd together.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.setDistance = function (distance) {\n    this.updateDistance(distance, this.minDistance);\n  };\n  /**\n   * Set the minimum distance between clusters. Will be capped at the\n   * configured distance.\n   * @param {number} minDistance The minimum distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.setMinDistance = function (minDistance) {\n    this.updateDistance(this.distance, minDistance);\n  };\n  /**\n   * The configured minimum distance between clusters.\n   * @return {number} The minimum distance in pixels.\n   * @api\n   */\n\n\n  Cluster.prototype.getMinDistance = function () {\n    return this.minDistance;\n  };\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource} source The new source for this instance.\n   * @api\n   */\n\n\n  Cluster.prototype.setSource = function (source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n\n    this.source = source;\n\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n\n    this.refresh();\n  };\n  /**\n   * Handle the source changing.\n   */\n\n\n  Cluster.prototype.refresh = function () {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  /**\n   * Update the distances and refresh the source if necessary.\n   * @param {number} distance The new distance.\n   * @param {number} minDistance The new minimum distance.\n   */\n\n\n  Cluster.prototype.updateDistance = function (distance, minDistance) {\n    var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n    var changed = distance !== this.distance || this.interpolationRatio !== ratio;\n    this.distance = distance;\n    this.minDistance = minDistance;\n    this.interpolationRatio = ratio;\n\n    if (changed) {\n      this.refresh();\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  Cluster.prototype.cluster = function () {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n\n    var extent = createEmpty();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    /** @type {Object<string, true>} */\n\n    var clustered = {};\n\n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n\n      if (!(getUid(feature) in clustered)) {\n        var geometry = this.geometryFunction(feature);\n\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n          var neighbors = this.source.getFeaturesInExtent(extent).filter(function (neighbor) {\n            var uid = getUid(neighbor);\n\n            if (uid in clustered) {\n              return false;\n            }\n\n            clustered[uid] = true;\n            return true;\n          });\n          this.features.push(this.createCluster(neighbors, extent));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Feature>} features Features\n   * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n\n\n  Cluster.prototype.createCluster = function (features, extent) {\n    var centroid = [0, 0];\n\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry_1 = this.geometryFunction(features[i]);\n\n      if (geometry_1) {\n        addCoordinate(centroid, geometry_1.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n\n    scaleCoordinate(centroid, 1 / features.length);\n    var searchCenter = getCenter(extent);\n    var ratio = this.interpolationRatio;\n    var geometry = new Point([centroid[0] * (1 - ratio) + searchCenter[0] * ratio, centroid[1] * (1 - ratio) + searchCenter[1] * ratio]);\n\n    if (this.createCustomCluster_) {\n      return this.createCustomCluster_(geometry, features);\n    } else {\n      return new Feature({\n        geometry: geometry,\n        features: features\n      });\n    }\n  };\n\n  return Cluster;\n}(VectorSource);\n\nexport default Cluster;","map":{"version":3,"sources":["../src/source/Cluster.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/source/Cluster\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport { add as addCoordinate, scale as scaleCoordinate } from '../coordinate.js';\nimport { assert } from '../asserts.js';\nimport { buffer, createEmpty, createOrUpdateFromCoordinate, getCenter, } from '../extent.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<Feature>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point} and an array\n * of {@link module:ol/Feature} included in this cluster. Must return a\n * {@link module:ol/Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource} [source] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nvar Cluster = /** @class */ (function (_super) {\n    __extends(Cluster, _super);\n    /**\n     * @param {Options} options Cluster options.\n     */\n    function Cluster(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            wrapX: options.wrapX,\n        }) || this;\n        /**\n         * @type {number|undefined}\n         * @protected\n         */\n        _this.resolution = undefined;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.distance = options.distance !== undefined ? options.distance : 20;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.minDistance = options.minDistance || 0;\n        /**\n         * @type {number}\n         * @protected\n         */\n        _this.interpolationRatio = 0;\n        /**\n         * @type {Array<Feature>}\n         * @protected\n         */\n        _this.features = [];\n        /**\n         * @param {Feature} feature Feature.\n         * @return {Point} Cluster calculation point.\n         * @protected\n         */\n        _this.geometryFunction =\n            options.geometryFunction ||\n                function (feature) {\n                    var geometry = feature.getGeometry();\n                    assert(geometry.getType() == GeometryType.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n                    return geometry;\n                };\n        /**\n         * @type {function(Point, Array<Feature>):Feature}\n         * @private\n         */\n        _this.createCustomCluster_ = options.createCluster;\n        /**\n         * @type {VectorSource}\n         * @protected\n         */\n        _this.source = null;\n        _this.boundRefresh_ = _this.refresh.bind(_this);\n        _this.updateDistance(_this.distance, _this.minDistance);\n        _this.setSource(options.source || null);\n        return _this;\n    }\n    /**\n     * Remove all features from the source.\n     * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n     * @api\n     */\n    Cluster.prototype.clear = function (opt_fast) {\n        this.features.length = 0;\n        _super.prototype.clear.call(this, opt_fast);\n    };\n    /**\n     * Get the distance in pixels between clusters.\n     * @return {number} Distance.\n     * @api\n     */\n    Cluster.prototype.getDistance = function () {\n        return this.distance;\n    };\n    /**\n     * Get a reference to the wrapped source.\n     * @return {VectorSource} Source.\n     * @api\n     */\n    Cluster.prototype.getSource = function () {\n        return this.source;\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n        this.source.loadFeatures(extent, resolution, projection);\n        if (resolution !== this.resolution) {\n            this.resolution = resolution;\n            this.refresh();\n        }\n    };\n    /**\n     * Set the distance within which features will be clusterd together.\n     * @param {number} distance The distance in pixels.\n     * @api\n     */\n    Cluster.prototype.setDistance = function (distance) {\n        this.updateDistance(distance, this.minDistance);\n    };\n    /**\n     * Set the minimum distance between clusters. Will be capped at the\n     * configured distance.\n     * @param {number} minDistance The minimum distance in pixels.\n     * @api\n     */\n    Cluster.prototype.setMinDistance = function (minDistance) {\n        this.updateDistance(this.distance, minDistance);\n    };\n    /**\n     * The configured minimum distance between clusters.\n     * @return {number} The minimum distance in pixels.\n     * @api\n     */\n    Cluster.prototype.getMinDistance = function () {\n        return this.minDistance;\n    };\n    /**\n     * Replace the wrapped source.\n     * @param {VectorSource} source The new source for this instance.\n     * @api\n     */\n    Cluster.prototype.setSource = function (source) {\n        if (this.source) {\n            this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n        }\n        this.source = source;\n        if (source) {\n            source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n        }\n        this.refresh();\n    };\n    /**\n     * Handle the source changing.\n     */\n    Cluster.prototype.refresh = function () {\n        this.clear();\n        this.cluster();\n        this.addFeatures(this.features);\n    };\n    /**\n     * Update the distances and refresh the source if necessary.\n     * @param {number} distance The new distance.\n     * @param {number} minDistance The new minimum distance.\n     */\n    Cluster.prototype.updateDistance = function (distance, minDistance) {\n        var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n        var changed = distance !== this.distance || this.interpolationRatio !== ratio;\n        this.distance = distance;\n        this.minDistance = minDistance;\n        this.interpolationRatio = ratio;\n        if (changed) {\n            this.refresh();\n        }\n    };\n    /**\n     * @protected\n     */\n    Cluster.prototype.cluster = function () {\n        if (this.resolution === undefined || !this.source) {\n            return;\n        }\n        var extent = createEmpty();\n        var mapDistance = this.distance * this.resolution;\n        var features = this.source.getFeatures();\n        /** @type {Object<string, true>} */\n        var clustered = {};\n        for (var i = 0, ii = features.length; i < ii; i++) {\n            var feature = features[i];\n            if (!(getUid(feature) in clustered)) {\n                var geometry = this.geometryFunction(feature);\n                if (geometry) {\n                    var coordinates = geometry.getCoordinates();\n                    createOrUpdateFromCoordinate(coordinates, extent);\n                    buffer(extent, mapDistance, extent);\n                    var neighbors = this.source\n                        .getFeaturesInExtent(extent)\n                        .filter(function (neighbor) {\n                        var uid = getUid(neighbor);\n                        if (uid in clustered) {\n                            return false;\n                        }\n                        clustered[uid] = true;\n                        return true;\n                    });\n                    this.features.push(this.createCluster(neighbors, extent));\n                }\n            }\n        }\n    };\n    /**\n     * @param {Array<Feature>} features Features\n     * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n     * @return {Feature} The cluster feature.\n     * @protected\n     */\n    Cluster.prototype.createCluster = function (features, extent) {\n        var centroid = [0, 0];\n        for (var i = features.length - 1; i >= 0; --i) {\n            var geometry_1 = this.geometryFunction(features[i]);\n            if (geometry_1) {\n                addCoordinate(centroid, geometry_1.getCoordinates());\n            }\n            else {\n                features.splice(i, 1);\n            }\n        }\n        scaleCoordinate(centroid, 1 / features.length);\n        var searchCenter = getCenter(extent);\n        var ratio = this.interpolationRatio;\n        var geometry = new Point([\n            centroid[0] * (1 - ratio) + searchCenter[0] * ratio,\n            centroid[1] * (1 - ratio) + searchCenter[1] * ratio,\n        ]);\n        if (this.createCustomCluster_) {\n            return this.createCustomCluster_(geometry, features);\n        }\n        else {\n            return new Feature({\n                geometry: geometry,\n                features: features,\n            });\n        }\n    };\n    return Cluster;\n}(VectorSource));\nexport default Cluster;\n//# sourceMappingURL=Cluster.js.map"]},"metadata":{},"sourceType":"module"}