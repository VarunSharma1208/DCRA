{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/source/GeoTIFF\n */\n\n\nimport DataTile from './DataTile.js';\nimport State from './State.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff/src/geotiff.js';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { create as createDecoderWorker } from '../worker/geotiff-decoder.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { toSize } from '../size.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {Object} GeoTIFF\n * @property {function():Promise<number>} getImageCount Get the number of internal subfile images.\n * @property {function(number):Promise<GeoTIFFImage>} getImage Get the image at the specified index.\n */\n\n/**\n * @typedef {Object} MultiGeoTIFF\n * @property {function():Promise<number>} getImageCount Get the number of internal subfile images.\n * @property {function(number):Promise<GeoTIFFImage>} getImage Get the image at the specified index.\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nvar STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nvar STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n/**\n * @typedef {Object} GeoTIFFImage\n * @property {Object} fileDirectory The file directory.\n * @property {GeoKeys} geoKeys The parsed geo-keys.\n * @property {boolean} littleEndian Uses little endian byte order.\n * @property {Object} tiles The tile cache.\n * @property {boolean} isTiled The image is tiled.\n * @property {function():Array<number>} getBoundingBox Get the image bounding box.\n * @property {function():Array<number>} getOrigin Get the image origin.\n * @property {function(GeoTIFFImage):Array<number>} getResolution Get the image resolution.\n * @property {function():number} getWidth Get the pixel width of the image.\n * @property {function():number} getHeight Get the pixel height of the image.\n * @property {function():number} getTileWidth Get the pixel width of image tiles.\n * @property {function():number} getTileHeight Get the pixel height of image tiles.\n * @property {function():number|null} getGDALNoData Get the nodata value (or null if none).\n * @property {function():GDALMetadata|null} getGDALMetadata Get the raster stats (or null if none).\n * @property {function():number} getSamplesPerPixel Get the number of samples per pixel.\n */\n\nvar workerPool;\n\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool(undefined, createDecoderWorker());\n  }\n\n  return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\n\n\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    var fileDirectory = image.fileDirectory;\n    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\n\n\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.fileDirectory.ImageLength];\n  }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {number} The image resolution.\n */\n\n\nfunction getResolution(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage)[0];\n  } catch (_) {\n    return referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth;\n  }\n}\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\n\n\nfunction getProjection(image) {\n  var geoKeys = image.geoKeys;\n\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (geoKeys.ProjectedCSTypeGeoKey) {\n    var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    var projection = getCachedProjection(code);\n\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey) {\n    var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    var projection = getCachedProjection(code);\n\n    if (!projection) {\n      var units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units\n        });\n      }\n    }\n\n    return projection;\n  }\n\n  return null;\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\n\n\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    var requests = new Array(count);\n\n    for (var i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n\n    return Promise.all(requests);\n  });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\n\n\nfunction getImagesForSource(source) {\n  var request;\n\n  if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews);\n  } else {\n    request = tiffFromUrl(source.url);\n  }\n\n  return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\n\n\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    var length_1 = expected.length;\n\n    if (!Array.isArray(got) || length_1 != got.length) {\n      var error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n\n    for (var i = 0; i < length_1; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n\n    return;\n  }\n\n  got =\n  /** @type {number} */\n  got;\n\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\n\n\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n\n  return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\n\n\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n\n  return 255;\n}\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\n\n\nvar GeoTIFFSource =\n/** @class */\nfunction (_super) {\n  __extends(GeoTIFFSource, _super);\n  /**\n   * @param {Options} options Data tile options.\n   */\n\n\n  function GeoTIFFSource(options) {\n    var _this = _super.call(this, {\n      state: State.LOADING,\n      tileGrid: null,\n      projection: null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n\n\n    _this.sourceInfo_ = options.sources;\n    var numSources = _this.sourceInfo_.length;\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n\n    _this.sourceImagery_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    _this.resolutionFactors_ = new Array(numSources);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    _this.samplesPerPixel_;\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n\n    _this.nodataValues_;\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n\n    _this.metadata_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.normalize_ = options.normalize !== false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.addAlpha_ = false;\n    /**\n     * @type {Error}\n     * @private\n     */\n\n    _this.error_ = null;\n    /**\n     * @type {'readRasters' | 'readRGB'}\n     */\n\n    _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n\n    _this.setKey(_this.sourceInfo_.map(function (source) {\n      return source.url;\n    }).join(','));\n\n    var self = _this;\n    var requests = new Array(numSources);\n\n    for (var i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(_this.sourceInfo_[i]);\n    }\n\n    Promise.all(requests).then(function (sources) {\n      self.configure_(sources);\n    }).catch(function (error) {\n      console.error(error); // eslint-disable-line no-console\n\n      self.error_ = error;\n      self.setState(State.ERROR);\n    });\n    return _this;\n  }\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n\n\n  GeoTIFFSource.prototype.getError = function () {\n    return this.error_;\n  };\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n\n\n  GeoTIFFSource.prototype.configure_ = function (sources) {\n    var extent;\n    var origin;\n    var tileSizes;\n    var resolutions;\n    var samplesPerPixel = new Array(sources.length);\n    var nodataValues = new Array(sources.length);\n    var metadata = new Array(sources.length);\n    var minZoom = 0;\n    var sourceCount = sources.length;\n\n    var _loop_1 = function _loop_1(sourceIndex) {\n      var images = sources[sourceIndex];\n      var imageCount = images.length;\n      var sourceExtent = void 0;\n      var sourceOrigin = void 0;\n      var sourceTileSizes = new Array(imageCount);\n      var sourceResolutions = new Array(imageCount);\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (var imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        var image = images[imageIndex];\n        var nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata();\n        nodataValues[sourceIndex][imageIndex] = nodataValue === null ? NaN : nodataValue;\n        var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();\n        var level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        sourceResolutions[level] = getResolution(image, images[0]);\n        sourceTileSizes[level] = [image.getTileWidth(), image.getTileHeight()];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        var message = \"Origin mismatch for source \" + sourceIndex + \", got [\" + sourceOrigin + \"] but expected [\" + origin + \"]\";\n        assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this_1.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n\n        var resolutionFactor_1 = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];\n        this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;\n        var scaledSourceResolutions = sourceResolutions.map(function (resolution) {\n          return resolution *= resolutionFactor_1;\n        });\n        var message = \"Resolution mismatch for source \" + sourceIndex + \", got [\" + scaledSourceResolutions + \"] but expected [\" + resolutions + \"]\";\n        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.005, message, this_1.viewRejector);\n      }\n\n      if (!tileSizes) {\n        tileSizes = sourceTileSizes;\n      } else {\n        assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, \"Tile size mismatch for source \" + sourceIndex, this_1.viewRejector);\n      }\n\n      this_1.sourceImagery_[sourceIndex] = images.reverse();\n    };\n\n    var this_1 = this;\n\n    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      _loop_1(sourceIndex);\n    }\n\n    for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      var sourceImagery = this.sourceImagery_[i];\n\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      var firstSource = sources[0];\n\n      for (var i = firstSource.length - 1; i >= 0; --i) {\n        var image = firstSource[i];\n        var projection = getProjection(image);\n\n        if (projection) {\n          this.projection = projection;\n          break;\n        }\n      }\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata; // decide if we need to add an alpha band to handle nodata\n\n    outer: for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      var values = nodataValues[sourceIndex]; // option 2: check image metadata for limited bands\n\n      var bands = this.sourceInfo_[sourceIndex].bands;\n\n      if (bands) {\n        for (var i = 0; i < bands.length; ++i) {\n          if (!isNaN(values[bands[i] - 1])) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n\n        continue;\n      } // option 3: check image metadata for all bands\n\n\n      for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (!isNaN(values[imageIndex])) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    var additionalBands = this.addAlpha_ ? 1 : 0;\n    this.bandCount = samplesPerPixel.reduce(function (accumulator, value) {\n      accumulator += value;\n      return accumulator;\n    }, 0) + additionalBands;\n    var tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: tileSizes\n    });\n    this.tileGrid = tileGrid;\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState(State.READY);\n    this.viewResolver({\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: 0\n    });\n  };\n\n  GeoTIFFSource.prototype.loadTile_ = function (z, x, y) {\n    var size = toSize(this.tileGrid.getTileSize(z));\n    var sourceCount = this.sourceImagery_.length;\n    var requests = new Array(sourceCount);\n    var addAlpha = this.addAlpha_;\n    var bandCount = this.bandCount;\n    var samplesPerPixel = this.samplesPerPixel_;\n    var nodataValues = this.nodataValues_;\n    var sourceInfo = this.sourceInfo_;\n\n    var _loop_2 = function _loop_2(sourceIndex) {\n      var source = sourceInfo[sourceIndex];\n      var resolutionFactor = this_2.resolutionFactors_[sourceIndex];\n      var pixelBounds = [Math.round(x * (size[0] * resolutionFactor)), Math.round(y * (size[1] * resolutionFactor)), Math.round((x + 1) * (size[0] * resolutionFactor)), Math.round((y + 1) * (size[1] * resolutionFactor))];\n      var image = this_2.sourceImagery_[sourceIndex][z];\n      var samples = void 0;\n\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n      /** @type {number|Array<number>} */\n\n\n      var fillValue = void 0;\n\n      if (!isNaN(source.nodata)) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      requests[sourceIndex] = image[this_2.readMethod_]({\n        window: pixelBounds,\n        width: size[0],\n        height: size[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: getWorkerPool(),\n        interleave: false\n      });\n    };\n\n    var this_2 = this;\n\n    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      _loop_2(sourceIndex);\n    }\n\n    var pixelCount = size[0] * size[1];\n    var dataLength = pixelCount * bandCount;\n    var normalize = this.normalize_;\n    var metadata = this.metadata_;\n    return Promise.all(requests).then(function (sourceSamples) {\n      /** @type {Uint8Array|Float32Array} */\n      var data;\n\n      if (normalize) {\n        data = new Uint8Array(dataLength);\n      } else {\n        data = new Float32Array(dataLength);\n      }\n\n      var dataIndex = 0;\n\n      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n        var transparent = addAlpha;\n\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n          var source = sourceInfo[sourceIndex];\n          var min = source.min;\n          var max = source.max;\n          var gain = void 0,\n              bias = void 0;\n\n          if (normalize) {\n            var stats = metadata[sourceIndex][0];\n\n            if (min === undefined) {\n              if (stats && STATISTICS_MINIMUM in stats) {\n                min = parseFloat(stats[STATISTICS_MINIMUM]);\n              } else {\n                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n\n            if (max === undefined) {\n              if (stats && STATISTICS_MAXIMUM in stats) {\n                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n              } else {\n                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n              }\n            }\n\n            gain = 255 / (max - min);\n            bias = -min * gain;\n          }\n\n          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n            var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n            var value = void 0;\n\n            if (normalize) {\n              value = clamp(gain * sourceValue + bias, 0, 255);\n            } else {\n              value = sourceValue;\n            }\n\n            if (!addAlpha) {\n              data[dataIndex] = value;\n            } else {\n              var nodata = source.nodata;\n\n              if (nodata === undefined) {\n                var bandIndex = void 0;\n\n                if (source.bands) {\n                  bandIndex = source.bands[sampleIndex] - 1;\n                } else {\n                  bandIndex = sampleIndex;\n                }\n\n                nodata = nodataValues[sourceIndex][bandIndex];\n              }\n\n              if (sourceValue !== nodata) {\n                transparent = false;\n                data[dataIndex] = value;\n              }\n            }\n\n            dataIndex++;\n          }\n        }\n\n        if (addAlpha) {\n          if (!transparent) {\n            data[dataIndex] = 255;\n          }\n\n          dataIndex++;\n        }\n      }\n\n      return data;\n    });\n  };\n\n  return GeoTIFFSource;\n}(DataTile);\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\n\n\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;","map":{"version":3,"sources":["../src/source/GeoTIFF.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport State from './State.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls, } from 'geotiff/src/geotiff.js';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent, } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { create as createDecoderWorker } from '../worker/geotiff-decoder.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { toSize } from '../size.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n/**\n * @typedef {Object} GeoTIFF\n * @property {function():Promise<number>} getImageCount Get the number of internal subfile images.\n * @property {function(number):Promise<GeoTIFFImage>} getImage Get the image at the specified index.\n */\n/**\n * @typedef {Object} MultiGeoTIFF\n * @property {function():Promise<number>} getImageCount Get the number of internal subfile images.\n * @property {function(number):Promise<GeoTIFFImage>} getImage Get the image at the specified index.\n */\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\nvar STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nvar STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n/**\n * @typedef {Object} GeoTIFFImage\n * @property {Object} fileDirectory The file directory.\n * @property {GeoKeys} geoKeys The parsed geo-keys.\n * @property {boolean} littleEndian Uses little endian byte order.\n * @property {Object} tiles The tile cache.\n * @property {boolean} isTiled The image is tiled.\n * @property {function():Array<number>} getBoundingBox Get the image bounding box.\n * @property {function():Array<number>} getOrigin Get the image origin.\n * @property {function(GeoTIFFImage):Array<number>} getResolution Get the image resolution.\n * @property {function():number} getWidth Get the pixel width of the image.\n * @property {function():number} getHeight Get the pixel height of the image.\n * @property {function():number} getTileWidth Get the pixel width of image tiles.\n * @property {function():number} getTileHeight Get the pixel height of image tiles.\n * @property {function():number|null} getGDALNoData Get the nodata value (or null if none).\n * @property {function():GDALMetadata|null} getGDALMetadata Get the raster stats (or null if none).\n * @property {function():number} getSamplesPerPixel Get the number of samples per pixel.\n */\nvar workerPool;\nfunction getWorkerPool() {\n    if (!workerPool) {\n        workerPool = new Pool(undefined, createDecoderWorker());\n    }\n    return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n    try {\n        return image.getBoundingBox();\n    }\n    catch (_) {\n        var fileDirectory = image.fileDirectory;\n        return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n    }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n    try {\n        return image.getOrigin().slice(0, 2);\n    }\n    catch (_) {\n        return [0, image.fileDirectory.ImageLength];\n    }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {number} The image resolution.\n */\nfunction getResolution(image, referenceImage) {\n    try {\n        return image.getResolution(referenceImage)[0];\n    }\n    catch (_) {\n        return (referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth);\n    }\n}\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n    var geoKeys = image.geoKeys;\n    if (!geoKeys) {\n        return null;\n    }\n    if (geoKeys.ProjectedCSTypeGeoKey) {\n        var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n        var projection = getCachedProjection(code);\n        if (!projection) {\n            var units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n            if (units) {\n                projection = new Projection({\n                    code: code,\n                    units: units,\n                });\n            }\n        }\n        return projection;\n    }\n    if (geoKeys.GeographicTypeGeoKey) {\n        var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n        var projection = getCachedProjection(code);\n        if (!projection) {\n            var units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n            if (units) {\n                projection = new Projection({\n                    code: code,\n                    units: units,\n                });\n            }\n        }\n        return projection;\n    }\n    return null;\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n    return tiff.getImageCount().then(function (count) {\n        var requests = new Array(count);\n        for (var i = 0; i < count; ++i) {\n            requests[i] = tiff.getImage(i);\n        }\n        return Promise.all(requests);\n    });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source) {\n    var request;\n    if (source.overviews) {\n        request = tiffFromUrls(source.url, source.overviews);\n    }\n    else {\n        request = tiffFromUrl(source.url);\n    }\n    return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n    if (Array.isArray(expected)) {\n        var length_1 = expected.length;\n        if (!Array.isArray(got) || length_1 != got.length) {\n            var error = new Error(message);\n            rejector(error);\n            throw error;\n        }\n        for (var i = 0; i < length_1; ++i) {\n            assertEqual(expected[i], got[i], tolerance, message, rejector);\n        }\n        return;\n    }\n    got = /** @type {number} */ (got);\n    if (Math.abs(expected - got) > tolerance * expected) {\n        throw new Error(message);\n    }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n    if (array instanceof Int8Array) {\n        return -128;\n    }\n    if (array instanceof Int16Array) {\n        return -32768;\n    }\n    if (array instanceof Int32Array) {\n        return -2147483648;\n    }\n    if (array instanceof Float32Array) {\n        return 1.2e-38;\n    }\n    return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n    if (array instanceof Int8Array) {\n        return 127;\n    }\n    if (array instanceof Uint8Array) {\n        return 255;\n    }\n    if (array instanceof Uint8ClampedArray) {\n        return 255;\n    }\n    if (array instanceof Int16Array) {\n        return 32767;\n    }\n    if (array instanceof Uint16Array) {\n        return 65535;\n    }\n    if (array instanceof Int32Array) {\n        return 2147483647;\n    }\n    if (array instanceof Uint32Array) {\n        return 4294967295;\n    }\n    if (array instanceof Float32Array) {\n        return 3.4e38;\n    }\n    return 255;\n}\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\nvar GeoTIFFSource = /** @class */ (function (_super) {\n    __extends(GeoTIFFSource, _super);\n    /**\n     * @param {Options} options Data tile options.\n     */\n    function GeoTIFFSource(options) {\n        var _this = _super.call(this, {\n            state: State.LOADING,\n            tileGrid: null,\n            projection: null,\n            opaque: options.opaque,\n            transition: options.transition,\n            interpolate: options.interpolate !== false,\n            wrapX: options.wrapX,\n        }) || this;\n        /**\n         * @type {Array<SourceInfo>}\n         * @private\n         */\n        _this.sourceInfo_ = options.sources;\n        var numSources = _this.sourceInfo_.length;\n        /**\n         * @type {Array<Array<GeoTIFFImage>>}\n         * @private\n         */\n        _this.sourceImagery_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.resolutionFactors_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.samplesPerPixel_;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.nodataValues_;\n        /**\n         * @type {Array<Array<GDALMetadata>>}\n         * @private\n         */\n        _this.metadata_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.normalize_ = options.normalize !== false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.addAlpha_ = false;\n        /**\n         * @type {Error}\n         * @private\n         */\n        _this.error_ = null;\n        /**\n         * @type {'readRasters' | 'readRGB'}\n         */\n        _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n        _this.setKey(_this.sourceInfo_.map(function (source) { return source.url; }).join(','));\n        var self = _this;\n        var requests = new Array(numSources);\n        for (var i = 0; i < numSources; ++i) {\n            requests[i] = getImagesForSource(_this.sourceInfo_[i]);\n        }\n        Promise.all(requests)\n            .then(function (sources) {\n            self.configure_(sources);\n        })\n            .catch(function (error) {\n            console.error(error); // eslint-disable-line no-console\n            self.error_ = error;\n            self.setState(State.ERROR);\n        });\n        return _this;\n    }\n    /**\n     * @return {Error} A source loading error. When the source state is `error`, use this function\n     * to get more information about the error. To debug a faulty configuration, you may want to use\n     * a listener like\n     * ```js\n     * geotiffSource.on('change', () => {\n     *   if (geotiffSource.getState() === 'error') {\n     *     console.error(geotiffSource.getError());\n     *   }\n     * });\n     * ```\n     */\n    GeoTIFFSource.prototype.getError = function () {\n        return this.error_;\n    };\n    /**\n     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n     * must have the same internal tiled structure.\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     * @private\n     */\n    GeoTIFFSource.prototype.configure_ = function (sources) {\n        var extent;\n        var origin;\n        var tileSizes;\n        var resolutions;\n        var samplesPerPixel = new Array(sources.length);\n        var nodataValues = new Array(sources.length);\n        var metadata = new Array(sources.length);\n        var minZoom = 0;\n        var sourceCount = sources.length;\n        var _loop_1 = function (sourceIndex) {\n            var images = sources[sourceIndex];\n            var imageCount = images.length;\n            var sourceExtent = void 0;\n            var sourceOrigin = void 0;\n            var sourceTileSizes = new Array(imageCount);\n            var sourceResolutions = new Array(imageCount);\n            nodataValues[sourceIndex] = new Array(imageCount);\n            metadata[sourceIndex] = new Array(imageCount);\n            for (var imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n                var image = images[imageIndex];\n                var nodataValue = image.getGDALNoData();\n                metadata[sourceIndex][imageIndex] = image.getGDALMetadata();\n                nodataValues[sourceIndex][imageIndex] =\n                    nodataValue === null ? NaN : nodataValue;\n                var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;\n                samplesPerPixel[sourceIndex] = wantedSamples\n                    ? wantedSamples.length\n                    : image.getSamplesPerPixel();\n                var level = imageCount - (imageIndex + 1);\n                if (!sourceExtent) {\n                    sourceExtent = getBoundingBox(image);\n                }\n                if (!sourceOrigin) {\n                    sourceOrigin = getOrigin(image);\n                }\n                sourceResolutions[level] = getResolution(image, images[0]);\n                sourceTileSizes[level] = [image.getTileWidth(), image.getTileHeight()];\n            }\n            if (!extent) {\n                extent = sourceExtent;\n            }\n            else {\n                getIntersection(extent, sourceExtent, extent);\n            }\n            if (!origin) {\n                origin = sourceOrigin;\n            }\n            else {\n                var message = \"Origin mismatch for source \" + sourceIndex + \", got [\" + sourceOrigin + \"] but expected [\" + origin + \"]\";\n                assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);\n            }\n            if (!resolutions) {\n                resolutions = sourceResolutions;\n                this_1.resolutionFactors_[sourceIndex] = 1;\n            }\n            else {\n                if (resolutions.length - minZoom > sourceResolutions.length) {\n                    minZoom = resolutions.length - sourceResolutions.length;\n                }\n                var resolutionFactor_1 = resolutions[resolutions.length - 1] /\n                    sourceResolutions[sourceResolutions.length - 1];\n                this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;\n                var scaledSourceResolutions = sourceResolutions.map(function (resolution) { return (resolution *= resolutionFactor_1); });\n                var message = \"Resolution mismatch for source \" + sourceIndex + \", got [\" + scaledSourceResolutions + \"] but expected [\" + resolutions + \"]\";\n                assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.005, message, this_1.viewRejector);\n            }\n            if (!tileSizes) {\n                tileSizes = sourceTileSizes;\n            }\n            else {\n                assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, \"Tile size mismatch for source \" + sourceIndex, this_1.viewRejector);\n            }\n            this_1.sourceImagery_[sourceIndex] = images.reverse();\n        };\n        var this_1 = this;\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            _loop_1(sourceIndex);\n        }\n        for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n            var sourceImagery = this.sourceImagery_[i];\n            while (sourceImagery.length < resolutions.length) {\n                sourceImagery.unshift(undefined);\n            }\n        }\n        if (!this.getProjection()) {\n            var firstSource = sources[0];\n            for (var i = firstSource.length - 1; i >= 0; --i) {\n                var image = firstSource[i];\n                var projection = getProjection(image);\n                if (projection) {\n                    this.projection = projection;\n                    break;\n                }\n            }\n        }\n        this.samplesPerPixel_ = samplesPerPixel;\n        this.nodataValues_ = nodataValues;\n        this.metadata_ = metadata;\n        // decide if we need to add an alpha band to handle nodata\n        outer: for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            // option 1: source is configured with a nodata value\n            if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n                this.addAlpha_ = true;\n                break;\n            }\n            var values = nodataValues[sourceIndex];\n            // option 2: check image metadata for limited bands\n            var bands = this.sourceInfo_[sourceIndex].bands;\n            if (bands) {\n                for (var i = 0; i < bands.length; ++i) {\n                    if (!isNaN(values[bands[i] - 1])) {\n                        this.addAlpha_ = true;\n                        break outer;\n                    }\n                }\n                continue;\n            }\n            // option 3: check image metadata for all bands\n            for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n                if (!isNaN(values[imageIndex])) {\n                    this.addAlpha_ = true;\n                    break outer;\n                }\n            }\n        }\n        var additionalBands = this.addAlpha_ ? 1 : 0;\n        this.bandCount =\n            samplesPerPixel.reduce(function (accumulator, value) {\n                accumulator += value;\n                return accumulator;\n            }, 0) + additionalBands;\n        var tileGrid = new TileGrid({\n            extent: extent,\n            minZoom: minZoom,\n            origin: origin,\n            resolutions: resolutions,\n            tileSizes: tileSizes,\n        });\n        this.tileGrid = tileGrid;\n        this.setLoader(this.loadTile_.bind(this));\n        this.setState(State.READY);\n        this.viewResolver({\n            projection: this.projection,\n            resolutions: resolutions,\n            center: toUserCoordinate(getCenter(extent), this.projection),\n            extent: toUserExtent(extent, this.projection),\n            zoom: 0,\n        });\n    };\n    GeoTIFFSource.prototype.loadTile_ = function (z, x, y) {\n        var size = toSize(this.tileGrid.getTileSize(z));\n        var sourceCount = this.sourceImagery_.length;\n        var requests = new Array(sourceCount);\n        var addAlpha = this.addAlpha_;\n        var bandCount = this.bandCount;\n        var samplesPerPixel = this.samplesPerPixel_;\n        var nodataValues = this.nodataValues_;\n        var sourceInfo = this.sourceInfo_;\n        var _loop_2 = function (sourceIndex) {\n            var source = sourceInfo[sourceIndex];\n            var resolutionFactor = this_2.resolutionFactors_[sourceIndex];\n            var pixelBounds = [\n                Math.round(x * (size[0] * resolutionFactor)),\n                Math.round(y * (size[1] * resolutionFactor)),\n                Math.round((x + 1) * (size[0] * resolutionFactor)),\n                Math.round((y + 1) * (size[1] * resolutionFactor)),\n            ];\n            var image = this_2.sourceImagery_[sourceIndex][z];\n            var samples = void 0;\n            if (source.bands) {\n                samples = source.bands.map(function (bandNumber) {\n                    return bandNumber - 1;\n                });\n            }\n            /** @type {number|Array<number>} */\n            var fillValue = void 0;\n            if (!isNaN(source.nodata)) {\n                fillValue = source.nodata;\n            }\n            else {\n                if (!samples) {\n                    fillValue = nodataValues[sourceIndex];\n                }\n                else {\n                    fillValue = samples.map(function (sampleIndex) {\n                        return nodataValues[sourceIndex][sampleIndex];\n                    });\n                }\n            }\n            requests[sourceIndex] = image[this_2.readMethod_]({\n                window: pixelBounds,\n                width: size[0],\n                height: size[1],\n                samples: samples,\n                fillValue: fillValue,\n                pool: getWorkerPool(),\n                interleave: false,\n            });\n        };\n        var this_2 = this;\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            _loop_2(sourceIndex);\n        }\n        var pixelCount = size[0] * size[1];\n        var dataLength = pixelCount * bandCount;\n        var normalize = this.normalize_;\n        var metadata = this.metadata_;\n        return Promise.all(requests).then(function (sourceSamples) {\n            /** @type {Uint8Array|Float32Array} */\n            var data;\n            if (normalize) {\n                data = new Uint8Array(dataLength);\n            }\n            else {\n                data = new Float32Array(dataLength);\n            }\n            var dataIndex = 0;\n            for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n                var transparent = addAlpha;\n                for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n                    var source = sourceInfo[sourceIndex];\n                    var min = source.min;\n                    var max = source.max;\n                    var gain = void 0, bias = void 0;\n                    if (normalize) {\n                        var stats = metadata[sourceIndex][0];\n                        if (min === undefined) {\n                            if (stats && STATISTICS_MINIMUM in stats) {\n                                min = parseFloat(stats[STATISTICS_MINIMUM]);\n                            }\n                            else {\n                                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n                            }\n                        }\n                        if (max === undefined) {\n                            if (stats && STATISTICS_MAXIMUM in stats) {\n                                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n                            }\n                            else {\n                                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n                            }\n                        }\n                        gain = 255 / (max - min);\n                        bias = -min * gain;\n                    }\n                    for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n                        var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n                        var value = void 0;\n                        if (normalize) {\n                            value = clamp(gain * sourceValue + bias, 0, 255);\n                        }\n                        else {\n                            value = sourceValue;\n                        }\n                        if (!addAlpha) {\n                            data[dataIndex] = value;\n                        }\n                        else {\n                            var nodata = source.nodata;\n                            if (nodata === undefined) {\n                                var bandIndex = void 0;\n                                if (source.bands) {\n                                    bandIndex = source.bands[sampleIndex] - 1;\n                                }\n                                else {\n                                    bandIndex = sampleIndex;\n                                }\n                                nodata = nodataValues[sourceIndex][bandIndex];\n                            }\n                            if (sourceValue !== nodata) {\n                                transparent = false;\n                                data[dataIndex] = value;\n                            }\n                        }\n                        dataIndex++;\n                    }\n                }\n                if (addAlpha) {\n                    if (!transparent) {\n                        data[dataIndex] = 255;\n                    }\n                    dataIndex++;\n                }\n            }\n            return data;\n        });\n    };\n    return GeoTIFFSource;\n}(DataTile));\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;\n//# sourceMappingURL=GeoTIFF.js.map"]},"metadata":{},"sourceType":"module"}